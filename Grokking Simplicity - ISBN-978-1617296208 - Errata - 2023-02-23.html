<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                              "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en"
	lang="en">
	<head>
                <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
                <!-- HTML5 -->
                <meta charset="UTF-8"/>
		<style type="text/css">
                    .bodyContainer {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    padding-left: 32px;
    padding-right: 32px;
}

.notebookFor {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin: 24px 0px 0px;
    padding: 0px;
}

.bookTitle {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    padding: 0px;
}

.authors {
    font-size: 13px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin-top: 22px;
    margin-bottom: 24px; 
    padding: 0px;
}

.citation {
    font-size: 16px;
    font-weight: 500;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    margin-bottom: 24px;
    padding: 0px;
}

.sectionHeading {
    font-size: 24px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 24px;
    padding: 0px;
}

.noteHeading {
    font-size: 18px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 20px;
    padding: 0px;
}

.noteText {
    font-size: 18px;
    font-weight: 500;
    text-align: left;
    color: #333333;
    margin: 2px 0px 0px;
    padding: 0px;
}

.highlight_blue {
    color: rgb(178, 205, 251);
}

.highlight_orange {
    color: #ffd7ae;
}

.highlight_pink {
    color: rgb(255, 191, 206);
}

.highlight_yellow {
    color: rgb(247, 206, 0);
}

.notebookGraphic {
    margin-top: 10px;
    text-align: left;
}

.notebookGraphic img {
    -o-box-shadow:      0px 0px 5px #888;
    -icab-box-shadow:   0px 0px 5px #888;
    -khtml-box-shadow:  0px 0px 5px #888;
    -moz-box-shadow:    0px 0px 5px #888;
    -webkit-box-shadow: 0px 0px 5px #888;
    box-shadow:         0px 0px 5px #888; 
    max-width: 100%;
    height: auto;
}

hr {
    border: 0px none;
    height: 1px;
    background: none repeat scroll 0% 0% rgb(221, 221, 221);
}

		</style>
		<script type="text/javascript">
		    
		</script>
		<title></title>
	</head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
Notebook for
</div>
<div class="bookTitle">
Grokking Simplicity: Taming complex software with functional thinking
</div>
<div class="authors">
Normand, Eric
</div>
<div class="citation">
Citation (Chicago Style): Normand, Eric. <i>Grokking Simplicity: Taming complex software with functional thinking</i>. Manning Publications, 2021. Kindle edition.
</div>
<hr />

            <div class="sectionHeading">
Copyright
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) -  Page 11
</div>
<div class="noteText">
Tip 3: Take many small steps Tip 3: Take many small steps
</div>
<div class="noteHeading">
Note -  Page 12
</div>
<div class="noteText">
"Tip 3" duplicated.
</div>
<div class="sectionHeading">
About This Book
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) -  Page 28
</div>
<div class="noteText">
liveBook discussion forum
</div>
<div class="noteHeading">
Note -  Page 28
</div>
<div class="noteText">
Typo: Is "liveBook" the intended spelling/capitalization?
</div>
<div class="sectionHeading">
Chapter 2: Functional Thinking in Action
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Hard-won Lessons About Distributed Systems >  Page 63
</div>
<div class="noteText">
Hard- won lessons about distributed systems
</div>
<div class="noteHeading">
Note - Hard-won Lessons About Distributed Systems >  Page 63
</div>
<div class="noteText">
Do you mean "hard-learned lessons?"
</div>
<div class="sectionHeading">
Part 1: Actions, Calculations, and Data
</div>
<div class="noteHeading">
Note - Chapter 3: Distinguishing Actions, Calculations, and Data >  Page 75
</div>
<div class="noteText">
This figures mention a "part a" of the book. Is this so? Because only part 1 and part 2 seem to exist.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 3: Distinguishing Actions, Calculations, and Data >  Page 75
</div>
<div class="noteText">
There
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 3: Distinguishing Actions, Calculations, and Data >  Page 105
</div>
<div class="noteText">
function sendIssue() { var coupons = fetchCouponsFromDB(); var goodCoupons = selectCouponsByRank( coupons, "good"); var bestCoupons = selectCouponsByRank( coupons, "best"); var page = 0; ❶ var subscribers = fetchSubscribersFromDB( page); ❶ while( subscribers.length > 0) { ❷ var emails = emailsForSubscribers( subscribers, goodCoupons, bestCoupons); for( var e = 0; e < emails.length; e + +) { var email = emails[ e]; emailSystem.send( email); } page + +; ❸ subscribers = fetchSubscribersFromDB( page); ❸ } }
</div>
<div class="noteHeading">
Note - Chapter 3: Distinguishing Actions, Calculations, and Data >  Page 105
</div>
<div class="noteText">
Using page/offset can result in incorrect results in some cases and using monotonically increasing IDs maybe more appropriate.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 3: Distinguishing Actions, Calculations, and Data >  Page 107
</div>
<div class="noteText">
Of course, you, the programmer, can read the code and sometimes see what it will do. But as far as your running software is concerned, a function is a black box. You give it some inputs and an output comes out. You can’t really do much else with a function except run it.
</div>
<div class="noteHeading">
Note - Chapter 3: Distinguishing Actions, Calculations, and Data >  Page 107
</div>
<div class="noteText">
The blackbox is a huge advantage too. It makes it possible to build and reason about large systems.
</div>
<div class="noteHeading">
Note - Chapter 4: Extracting Calculations from Actions >  Page 128
</div>
<div class="noteText">
On the Oasis Kindle E-Reader (and even on the web), this figure is too small and not zoomable.

This is probably an issue in the device itself that makes figures that appear too small not zoomable but the author can likely work around this by making the figure appear a bit larger.

I confirmed the issue by making the text larger and then the figure became zoomable.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 4: Extracting Calculations from Actions >  Page 128
</div>
<div class="noteText">
George
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 4: Extracting Calculations from Actions >  Page 151
</div>
<div class="noteText">
In JavaScript, there is no direct way to copy an array. In this book, we will use the .slice() method, like this: array.slice() We will get into the details in chapter 6.
</div>
<div class="noteHeading">
Note - Chapter 4: Extracting Calculations from Actions >  Page 151
</div>
<div class="noteText">
`Array#concat()` probably creates a new array. Another issue, which would be nice to exist in questions and answers section, is shallow/deep copies.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 227
</div>
<div class="noteText">
var mailing_list = [];
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 227
</div>
<div class="noteText">
A naming conventions (e.g., "g_" prefix) for globals would be nice.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 237
</div>
<div class="noteText">
Copy- on- write
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 237
</div>
<div class="noteText">
Would be nice to add an implementation that uses the read and write functions as helpers. Just like you did with `shift`, for consistency/abstraction and having stronger guarantees for intended invariants.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 238
</div>
<div class="noteText">
Q: How is the copy- on- write add_element_to_cart() a read? A: The function add_element_to_cart() that implements the copy- on- write discipline is a read because it doesn’t modify the cart. You can look at it like it’s asking a question. The question might be “What would this cart look like if it also had this element?”
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 238
</div>
<div class="noteText">
This doesn't seem to make sense. Because this would shift the read/write categorization from the API implementor to the API user.

Which would break this categorization as there can always emerge an API user that categorize a previously write operation as a read operation.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 238
</div>
<div class="noteText">
A: Yes, it may be better to use an object. We often find that, in existing code, data structure decisions have already been made and we can’t easily change them. That’s the case here. We’ll have to continue with the shopping cart as an array.
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 238
</div>
<div class="noteText">
Another important consideration is that some usecases may require an ordered collection. Meaning that not all requirements can be supported efficiently with a given data structure (at least alone).

And it should be highlighted that implementing an API that makes it easier to change the underlying data structure is, in most cases, much more important than using the best data structure for current requirements.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 238
</div>
<div class="noteText">
Q: It seems like a lot of work to implement immutability. Is it worth it? Can it be easier?
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 238
</div>
<div class="noteText">
Why doesn't the answer mention Facebook's Immutable library?

The most probable reason that I can think of is to make it easier for readers to understand immutability better. But even then, and in any case, a tech-giant supported library can't just be ignored as if it doesn't exist and it should be dismissed explicitly and not implicitly.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 243
</div>
<div class="noteText">
Reads to immutable data structures are calculations
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 243
</div>
<div class="noteText">
It's very strange that deep copying and aliasing issues not mentioned even briefly this far.

Another point is that JS `freeze()` should probably be used or at least dismissed explicitly with a rationale.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 244
</div>
<div class="noteText">
Kim makes a good point.
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 244
</div>
<div class="noteText">
The figure where Kim makes the point is after this paragraph which makes this a reference to the point before it's mentioned.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 254
</div>
<div class="noteText">
Write a function setQuantity(), using objectSet(), that sets the quantity of an item. Make sure it implements the copy- on- write discipline. function setQuantity( item, new_quantity) { } ￼ Answer function setQuantity( item, new_quantity) { return objectSet( item, "quantity", new_quantity); } ￼ It’s your turn Write a function setQuantity(), using objectSet(), that sets the quantity of an item. Make sure it implements the copy- on- write discipline. function setQuantity( item, new_quantity) { } ￼ Answer function setQuantity( item, new_quantity) { return objectSet( item, "quantity", new_quantity); }
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 255
</div>
<div class="noteText">
`setQuantity` question and answer are repeated.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 258
</div>
<div class="noteText">
The references in the cart array may not change, but the values they refer to do change. That’s unnacceptable. The entire nested data structure has to remain unchanged for it to be immutable.
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 258
</div>
<div class="noteText">
And since it's so important, some effort and research should go into maintaining this. For example, use `freeze()`, blocking setting values for objects, or going as far as implementing a custom immutable object and array types.

This is very important because otherwise it's almost certain that part of the code will accidentally violate the immutability assumptions and result in incorrect behavior in subtle cases/scenario.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 6: Staying Immutable in a Mutable Language >  Page 265
</div>
<div class="noteText">
Copy- on- write is a discipline for ensuring our data is immutable. It means we make a copy and modify it instead of modifying the original.
</div>
<div class="noteHeading">
Note - Chapter 6: Staying Immutable in a Mutable Language >  Page 265
</div>
<div class="noteText">
It's better to write the system in a way that the majority of the discipline is built-in and enforced automatically. Only where the language or technology can't enforce this easily should conventions and discipline be used.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 7: Staying Immutable with Untrusted Code >  Page 287
</div>
<div class="noteText">
A dialogue between copy- on- write and defensive copying
</div>
<div class="noteHeading">
Note - Chapter 7: Staying Immutable with Untrusted Code >  Page 287
</div>
<div class="noteText">
Hilarious!
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 7: Staying Immutable with Untrusted Code >  Page 291
</div>
<div class="noteText">
Maybe. If you analyze the source code, you might discover that it doesn’t modify the data you pass it. However, also be on the lookout for other things it might do, like pass the data to a third part of the code.
</div>
<div class="noteHeading">
Note - Chapter 7: Staying Immutable with Untrusted Code >  Page 291
</div>
<div class="noteText">
Pardon my french but this is a disaster waiting to happen. All the code outside the safe zone should be assumed to modify state. And even if it doesn't at this point of time, it may very well do in the future and it would still be within its rights to do so.

TLDR; the unsafe zone may, by definition, change state as it sees fit.

One way to think about this is that if the code outside the safe zone can be assumed by the safe zone to not change state, then it is part of the safe zone. But we know for a fact that it isn't. Which results in a logical contradiction.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 7: Staying Immutable with Untrusted Code >  Page 291
</div>
<div class="noteText">
Yes. If you can afford it, a rewrite using copy- on- write would solve the problem.
</div>
<div class="noteHeading">
Note - Chapter 7: Staying Immutable with Untrusted Code >  Page 291
</div>
<div class="noteText">
This should be discouraged especially in the beginning as it can make it hard to debug issues as you would have to suspect both the safe/unsafe zone integration and the copy-on-write changes.

Another alternative is the strangler pattern: integrate both zones and then migrate parts of the unsafe zone to the safe zone gradually. All this without making unnecessary changes so that these changes are in dedicated version-control commits that can be reviewed/recorded one-by-one.
</div>
<div class="noteHeading">
Note - Chapter 7: Staying Immutable with Untrusted Code >  Page 291
</div>
<div class="noteText">
Not really sure if this will be discussed in the book later. But one very effective technique is to have dedicated types that maintain the safe zone invariants. These types would also have operations to convert to the unsafe zone format. The safe zone would only deal with these types and take them as arguments.

In a sense, the safe zone can't even work without types that are guaranteed to be safe and so the unsafe zone (which will be eliminated gradually) will be forced and responsible for the safe/unsafe conversions.

Here's a simple example:
```pseudo-code
Safe.from(unsafeObjectOrArray);
safeObjectOrArray.toUnsafe();
```

Even better, the safety properties of the dedicated types can be enforced at compile-time if the language supports this. This way the safety is codified and discipline/convention is almost at the optimal level (hard to beat this) as it's mostly constrained to implementing the safe types and conversions correctly and using the right parameter and return types.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 7: Staying Immutable with Untrusted Code >  Page 291
</div>
<div class="noteText">
Summary
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 8: Stratified Design: Part 1 >  Page 303
</div>
<div class="noteText">
If we had a function to check if an item was in the cart, we could use it instead of that low- level for loop.
</div>
<div class="noteHeading">
Note - Chapter 8: Stratified Design: Part 1 >  Page 303
</div>
<div class="noteText">
Why aren't `for of` used instead of incrementing an index? Which is not really needed and unnecessarily introduces the chance to use the incorrect length or index.

Another alternative is the `forEach()` (it can optionally include the index), `indexOf()`, and similar functions. Supporting older JS version is probably not the reason as `Object.assign()` and `Object.keys()` are quite recent.

</div>
<div class="noteHeading">
Note - Chapter 8: Stratified Design: Part 1 >  Page 309
</div>
<div class="noteText">
`isInCart()` is the one that called twice and not `add_item()`.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 8: Stratified Design: Part 1 >  Page 309
</div>
<div class="noteText">
Indeed,
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 8: Stratified Design: Part 1 >  Page 310
</div>
<div class="noteText">
Please do explore as fine- grained or high- level as you want.
</div>
<div class="noteHeading">
Note - Chapter 8: Stratified Design: Part 1 >  Page 310
</div>
<div class="noteText">
Do you mean "fine-grained or coarse-grained?"
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 8: Stratified Design: Part 1 >  Page 343
</div>
<div class="noteText">
Design is difficult, different programmers often disagree as to the best design, and design depends on the situation.
</div>
<div class="noteHeading">
Note - Chapter 8: Stratified Design: Part 1 >  Page 343
</div>
<div class="noteText">
It's actually not that difficult once you follow the following discipline: everyone is entitled to their opinions but mine is the correct one *_^.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 9: Stratified Design: Part 2 >  Page 372
</div>
<div class="noteText">
Two choices for coding the marketing campaign
</div>
<div class="noteHeading">
Note - Chapter 9: Stratified Design: Part 2 >  Page 372
</div>
<div class="noteText">
The code choices are written twice. Is this intentional?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 9: Stratified Design: Part 2 >  Page 392
</div>
<div class="noteText">
Testing code at the bottom benefits you more in the long run.
</div>
<div class="noteHeading">
Note - Chapter 9: Stratified Design: Part 2 >  Page 392
</div>
<div class="noteText">
Should mention there are other very important factors to consider.

For example, test at the top can catch specification/requirement errors where all the components at the bottom behaves correctly locally but is solving the wrong problem.

I've seen this many times where the tests for the bottom all pass and are correct but the system produces the wrong results even though each layer is perfectly correct.

This is very dangerous as it gives false confidence and can even cause major bugs to creep into production.
</div>
<div class="sectionHeading">
Part 2: First-Class Abstractions
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 409
</div>
<div class="noteText">
You might think that using strings like this is unsafe. We’ll discuss that in a few pages. For now, please just go with it!
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 409
</div>
<div class="noteText">
Yep! What's really unsafe is that any field can be set by the API user even if it's only intended for internal implementation use.

Unfortunately, languages like JS make this unsafety hard to avoid. And the difficulty of a safety feature/mechanism/mitigation can make even projects that are the best in the programming language ecosystem not use it.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 422
</div>
<div class="noteText">
function incrementFieldByName( cart, name, field) { if( field != = 'size' && field != = 'quantity')
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 422
</div>
<div class="noteText">
Could be better to have the whitelisted fields in an array and check the paramater existence.

This makes it easy to change. And, more importantly, avoids coding errors that are bound to happen with condition changes.

This applies to most blacklisting/whitelisting/mapping code. And is just like what you did with the cart whitelisting and fields mapping (API field name to implementation field name).
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 425
</div>
<div class="noteText">
This is an important principle of a style called data orientation, which is a style we will be using in the code for this book. We still can add an optional interface with abstraction barriers as we saw in chapter 9.
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 425
</div>
<div class="noteText">
This is probably the Clojure school of thought. It definitely has big advantages.

But the disadvantages shouldn't be understated. Some of which are the following:
1. Different parts of the system may interpret/use the same data in a non-consistent manner which can lead to seemingly correct isolation while the resulting behavior is wrong.
2. Harder to maintain some invariants as different parts of the code may have different assumptions.
3. Harder to ensure data is valid as the data-oriented types can have any value anywhere.
4. Lack of locality as much behavior can ony be understood globally depending on how the different components behave which can only be understood by undertanding and going through them all.
5. Harder to enforce correctness/security boundaries as the types are the same for data outside and inside the safe zone.
6. Harder to guarantee, for example, existence of fields/data.

Some parts of a system would definitively benefit from data orientation greatly but that all parts would is intuitively wrong even for someone who doesn't know what a computer is.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 425
</div>
<div class="noteText">
The truth is that we don’t have an answer. There are good arguments on both sides. This book can’t really resolve this long- running issue. However, it is important to understand that the debate has two sides and nobody has clearly won yet. It isn’t obvious, even after careful study, if one is better than the other for producing quality software. For example, some studies suggest getting a good night” s sleep is more important for software quality than the difference between static and dynamic typing. (https:// increment.com/ teams/ the- epistemology- of- software- quality/)
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 426
</div>
<div class="noteText">
There's obviously no clear winner but some factors are extremely implortant and rarely mentioned.

For example, the static typing can add value that can't be substituted by any other tool/approach.

I've had first hand experience with this. I worked extensively with both Node.js and C. And found that even with high test coverage with Node.js, evolving/refactoring C is easier/safer with the help of the compiler. This is true even though C requires more precision due to its low-level nature.

This, of course, doesn't apply to all systems/projects but one strong argument against dynamic typing is that it can be very bug-prone if you program with the purpose of ensuring the correct behavior in all cases and not just for things to seem to work.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 426
</div>
<div class="noteText">
Many dynamically typed programming languages do pass around what amount to strings that represent fields on data structures. Prominent examples include JavaScript, Ruby, Clojure, and Python. And, yes, they often have typos and other errors due to incorrect strings. It happens. However, many large businesses are built on those languages, with billions— if not trillions— of dollars relying on those systems functioning correctly. We can get by with strings.
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 426
</div>
<div class="noteText">
Using large business as an argument doesn't make this that much better: large business were satisfied with waterfall for decades too.

Common sense is crucial and first principles should always be first (otherwise they would be second principles). Errors of this type can be the most dangerous and have the largest blast radius and contagion as people underestimate them as opposed to other mistakes.

IMHO, dynamic typing has some serious issues and risks for most non-trivial systems and its overuse is due to social-proof/pluralistic-ignorance/cargo-cult.

Dynamic languages aren't infamous enough and for some very good reasons like that there are often more than a dozen other concerns (hierarchy of needs) for a system/project that are much more important.

I'd argue that if you talk with people who both would be very honest and worked with dynamically typed languages in production (the real measure) systems, they would have much more appreciation for static typing.

Even mixed typing like Typescript can introduce risks for internal implementation that isn't as safe as it seems. And some of this is that if you allow dynamic-typing, doing static typing properly will be less of a motive.

Liskov is quite right in saying that deficiencies in static-typed languges are what makes dynamic languages more popular. I would add low-standards and tolerance for errors that can entirely be reviewed and prevented by machines instead of expensive human time that even after it's spent non-trivial risk would still exist.

One huge issue of dynamic typing is that a small change in one part of the system can cause another part to fail right now or in the future in a specific scenario. This possibility is far from paranoid as it can happen even if the project has a single maintainer that understands the whole system.

The essence of this issue is that parts of the system that a compiler can check and enforce can ony be correct if a human being ensures they are correct in all code paths.

One way a project that uses dynamic typing have good locality is to have extensive checking/validation everywhere. And that is impractical and other approaches are probably just mitigations.

And I personally think the author wouldn't have this long section and use "large businesses" as an argument if he doesn't have some doubts.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 427
</div>
<div class="noteText">
That JSON is just strings. The server will receive and parse it. The server hopes the message is well- formed JSON.
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 427
</div>
<div class="noteText">
The same arguments against dynamic typing go for JSON. They can work but as things change with time and as the no. of JSON API endpoints increase, you end up with an implicit schema that even the one that created it doesn't fully understand.

I've experienced this for a backend system with more than dozens of endpoints and more than a couple of clients.

And even thousands of lines of documentation (using RAML) didn't solve some serious issues.

The reasoning is quite simple: given a growing and changing data API, how can you enforce/document it without explicit versioning/schema?
The answer is probably that it's almost an implossibility with JSON and whatever you do will not be as good as tools with schema and even if it's it would have been better spent in core domain challenges.

One major issue is that with big monolithic systems this will get out of hand. And the same (or even worse) with non-monlithic (e.g., microservices) systems.
</div>
<div class="noteHeading">
Note - Chapter 10: First-Class Functions: Part 1 >  Page 461
</div>
<div class="noteText">
Wouldn't implementing error-logging globally make much more sense? For example, entrypoints of the system would wrap everything in a try/catch and report then re-throw unhandled errors/exceptions.

Errors/exceptions that are handled internally or gracefully in upper layers are mostly accounted for routine scenarios and would probably be noise if present in error-reports. And presenting them in error-reports is more involved and advanced of a feature anyway and may even be handled using a different strategy (e.g., metrics for business objectives).

Having to change many parts of the code could be considered a smell here and this should be weighted against simpler approaches/mechanisms that can get the largest ROI.

This may make using this error-handling to explain higher-order functions inappropriate as it encourages expensive changes to many parts and an infinite-scroll with a lazy-list could be much better.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 10: First-Class Functions: Part 1 >  Page 461
</div>
<div class="noteText">
Conclusion
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 11: First-Class Functions: Part 2 >  Page 465
</div>
<div class="noteText">
Jenna: 1 Really?
</div>
<div class="noteHeading">
Note - Chapter 11: First-Class Functions: Part 2 >  Page 465
</div>
<div class="noteText">
Typo: seems to be using the number "1" instead of the letter "I" and missing a leading space.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 11: First-Class Functions: Part 2 >  Page 470
</div>
<div class="noteText">
We did achieve a big benefit. We have codified and standardized the copy- on- write discipline for arrays. It no longer has to be written the same way all over the codebase. It’s in one place.
</div>
<div class="noteHeading">
Note - Chapter 11: First-Class Functions: Part 2 >  Page 470
</div>
<div class="noteText">
It would still not prevent any part of the codebase from violating the immutability/copy-on-write invariants. Safe immutable types would be much more practical as they can better enforce this.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 11: First-Class Functions: Part 2 >  Page 496
</div>
<div class="noteText">
We loop a lot, so it’s nice to have a higher- order function for getting those right (forEach()).
</div>
<div class="noteHeading">
Note - Chapter 11: First-Class Functions: Part 2 >  Page 496
</div>
<div class="noteText">
That's one great usecase as it eliminates the possibility of using the wrong variable for the array or the variable for the index. This is far from paranoia as it does happen in practice quite frequently.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 11: First-Class Functions: Part 2 >  Page 496
</div>
<div class="noteText">
We catch errors a lot, so something to do that in a standard way might also be helpful.
</div>
<div class="noteHeading">
Note - Chapter 11: First-Class Functions: Part 2 >  Page 496
</div>
<div class="noteText">
This still doesn't eliminate the contagion where function factories has to be used everywhere. This introduces also the possibility of forgetting to either use the factory or have a part close to an entry point not covered by a factory.

One tidbit that makes this contagious approach look ridiculous is that covering entry points of a system written in C and only logging exceptional errors can probably beat it.

This is an example of how almost all problems have simple and very effective approaches but it's too easy to get carried away with expensive approaches that may even have some serious flaws.

Error reporting is mostly a solved problem. And one way to think of how the contagious approach is broken is that it wouldn't be reasonable to use an error-reporting implementation/sdk that uses it.

Trying to spread error-related logic everywhere rarely turns out well. And it's hard to beat propagating errors by default and handling them gobally and only handling errors locally in special circumstances.

This contagion is obviously bad because it exhibits similar costs to actions.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 12: Functional Iteration >  Page 514
</div>
<div class="noteText">
Careful, now! map() is a very useful function. Functional programmers use it safely all the time. But it’s very simple (and that’s why we like it). Notice that it doesn’t check at all what gets added to the returned array. What if the customer does not have an email and customer.email is null or undefined? That null will get put into the array. This is the same problem we had before: If your language allows nulls (like JavaScript does), then you might get nulls sometimes. However, map() can multiply the problem since it will run the function over entire arrays. There are two solutions: Be mindful or use a language where null is impossible. And if you do expect nulls, but you want to get rid of them, the next tool, filter(), will help you with that.
</div>
<div class="noteHeading">
Note - Chapter 12: Functional Iteration >  Page 515
</div>
<div class="noteText">
Another is custom safe types/objects that can do validation on construction and maintain their invariants.

This may seem an overkill in JS but there aren't any practical alternatives that even come close.

One reason is lack of first principles, common sense, and pluralistic ignorance.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 12: Functional Iteration >  Page 527
</div>
<div class="noteText">
function customersPerCity( customers) { var cities = {}; forEach( customers, function( customer) { ❶ cities[ customer.address.city] + = 1; ❷ }); return cities; ❸ }
</div>
<div class="noteHeading">
Note - Chapter 12: Functional Iteration >  Page 528
</div>
<div class="noteText">
Not really sure but this may produce unexpected results because it can add `1` to `undefined`.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 12: Functional Iteration >  Page 534
</div>
<div class="noteText">
Givens Number.MAX_VALUE is the largest number possible in JavaScript. Number.MIN_VALUE is the smallest number possible in JavaScript.
</div>
<div class="noteHeading">
Note - Chapter 12: Functional Iteration >  Page 534
</div>
<div class="noteText">
These two constants are probably unsafe and similar constants that contain `SAFE` should probably be used instead.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 12: Functional Iteration >  Page 539
</div>
<div class="noteText">
reduce() has different names in different languages. You may also see it called fold(). There are sometimes variations like foldLeft() and foldRight(), which indicate the direction in which you process the list.
</div>
<div class="noteHeading">
Note - Chapter 12: Functional Iteration >  Page 539
</div>
<div class="noteText">
Not really sure but `fold` may have some subtle diferences (as compared to `reduce`) in some cases.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 556
</div>
<div class="noteText">
var biggestPurchases = map( bestCustomers, function( customer) { ❷ return maxKey( customer.purchases, {total: 0}, function( purchase) { return purchase.total; }); });
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 556
</div>
<div class="noteText">
This snippet is in more than one place and it looks suspicious because it implies that `purchase.total` is an object with a `total` field. Is this indeed the case?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 570
</div>
<div class="noteText">
Refactoring existing for loops to functional tools
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 570
</div>
<div class="noteText">
Missing some crucial factors. These are huge topics of their own but should at least be mentioned very briefly. Otherwise, it can (and does happen quite often in practice) that projects that just keep doing what they are doing (however average it maybe) end up with better outcomes as it's too easy to miss the mark and the right approach never works in all cases/contexts.

Some of them are the following:
1. How often this code changes. If it doesn't change much, it's better to invest in parts that change more (e.g., due to defects).
2. Risk of breaking system. Loops/functional-tools (or even tech or electricity) isn't the goal. The goal is to achieve business value and if changing a part of the code can affect this negatively then it shouldn't be done.
3. Automated testing to confirm the refactoring is correct. "Cover and modify" as recommended in "Working Effectively with Legacy Code." This, of course, doesn't make the preceding points any less necessary as non-anticipated factors/scenarios (e.g., lack of understanding of impact of change or just forgetting a minor detail) can cause defects.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 589
</div>
<div class="noteText">
Lodash: Functional tools for JavaScript
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 589
</div>
<div class="noteText">
Would be very useful to mention Facbook's Immutable.js or at least dismiss it explicitly with a brief rationale.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 589
</div>
<div class="noteText">
Official docs (https:// clojure.github.io/ clojure/ clojure.core- api.html)
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 589
</div>
<div class="noteText">
They probably do (or should) have a proper domain for many reasons. For example, `github.io` may be the next sourceforge project pages in the future.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 590
</div>
<div class="noteText">
Haskell Prelude (http:// www.cse.chalmers.se/ edu/ course/ TDA555/ tourofprelude.html)
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 590
</div>
<div class="noteText">
If this is official it should have a proper domain too and use HTTPS instead of plain HTTP.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 593
</div>
<div class="noteText">
They don’t modify their data sources, they chain well, and they are efficient because they fuse streams automatically.
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 593
</div>
<div class="noteText">
Lodash probably has some fusing features too using `_.chain()` (or maybe a different name).
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 606
</div>
<div class="noteText">
_. chain( numbers) .map( function(_e, i) { return numbers.slice( i, i + window); }) .map( average) .value();
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 606
</div>
<div class="noteText">
This is probably fused but this is hard to know for the reader.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 13: Chaining Functional Tools >  Page 607
</div>
<div class="noteText">
We can combine functional tools into multi- tep chains.
</div>
<div class="noteHeading">
Note - Chapter 13: Chaining Functional Tools >  Page 607
</div>
<div class="noteText">
Typo: "multi-tep" instead of "multi-step."
</div>
<div class="noteHeading">
Note - Chapter 14: Functional Tools for Nested Data >  Page 671
</div>
<div class="noteText">
Incorrect capitalization.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 14: Functional Tools for Nested Data >  Page 671
</div>
<div class="noteText">
modifyUSer
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 703
</div>
<div class="noteText">
Actions on different timelines may interleave if they can occur between each other. This happens when multiple threads run at the same time.
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 703
</div>
<div class="noteText">
This seems to imply that this only happens with multi-threading and a reader can forget the crucial fact that this can happen, for example, in single-threaded event-loop implementations.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 705
</div>
<div class="noteText">
Like interleavings, the possible orderings are also dependent on your platform’s threading model.
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 705
</div>
<div class="noteText">
Concurrency-model can be more accurate than threading-model. For example, a single-threading model with an event-loop is vastly different from a single-threaded synchronous model.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 707
</div>
<div class="noteText">
Coordinating between timelines means eliminating possible orderings that don’t give us the right result.
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 707
</div>
<div class="noteText">
Or preferably only allowing a very limited set of orderings that are known to be safe. This can be achieved, in some cases, using state-machine-like techniques.
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 710
</div>
<div class="noteText">
Not really sure but the order which the event-loop runs jobs maybe an implementation-detail.

For example, even when using `setImmediate()`, it's possible for the implementation to run the jobs in a non-FIFO order. Even if it does run them in a FIFO order right now, this may change in the future for whatever reason.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 710
</div>
<div class="noteText">
What
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 715
</div>
<div class="noteText">
In JavaScript, this boils down to two simplifying steps:
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 715
</div>
<div class="noteText">
Diagramming steps and JS simplifying steps seems to be mentioned twice very closely. Seems like this is a remnant of an early draft.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 724
</div>
<div class="noteText">
Answer 3. A B C 4. B A C 5. B C A
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 724
</div>
<div class="noteText">
Diagramming these would be very useful.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 750
</div>
<div class="noteText">
￼ Answer 1. T, 2. F, 3. F, 4. T, 5. F, 6. F, 7. T, 8. T, 9. T, 10. T
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 750
</div>
<div class="noteText">
Detailed answers would be very useful here.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 751
</div>
<div class="noteText">
So what’s the solution? More callbacks!
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 751
</div>
<div class="noteText">
Hopefully async/await or at least promises would be used instead of callbacks later in the book as it would be sad for readers to learn handling asynchrouny the hard way.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 15: Isolating Timelines >  Page 756
</div>
<div class="noteText">
function async( a) { ❶… action1( b); }
</div>
<div class="noteHeading">
Note - Chapter 15: Isolating Timelines >  Page 756
</div>
<div class="noteText">
Using `async` which is a keyword in modern JS implementations maybe problematic.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 16: Sharing Resources Between Timelines >  Page 771
</div>
<div class="noteText">
Answer The following can be problematic if shared between timelines: 1, 2, 4, 6, 7.
</div>
<div class="noteHeading">
Note - Chapter 16: Sharing Resources Between Timelines >  Page 771
</div>
<div class="noteText">
A detailed answer would be useful here.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 16: Sharing Resources Between Timelines >  Page 796
</div>
<div class="noteText">
By wrapping the variables in a function scope, we are ensuring that nothing can modify them outside of the small amount of code within the function. It also lets us make multiple queues, although they all do the same thing (add items to the cart).
</div>
<div class="noteHeading">
Note - Chapter 16: Sharing Resources Between Timelines >  Page 796
</div>
<div class="noteText">
This is probably a solved problem with reactive-extensions which is a very underused tool. Otherwise adhoc solutions are just like the issues that made us use functional programming in the first place.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 16: Sharing Resources Between Timelines >  Page 805
</div>
<div class="noteText">
We’ve made a generic queue! Everything inside the Queue() function is generic. The nongeneric stuff is passed in as an argument. Let’s take a moment to reflect on what we’ve done.
</div>
<div class="noteHeading">
Note - Chapter 16: Sharing Resources Between Timelines >  Page 805
</div>
<div class="noteText">
The `Queue` name here is quite misleading as it implies that it's the data-structure and `JobQueue` would probably be more appropriate.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 16: Sharing Resources Between Timelines >  Page 809
</div>
<div class="noteText">
We want to be able to run the callback unconditionally, so we use this idiom to replace an undefined callback with a function that does nothing.
</div>
<div class="noteHeading">
Note - Chapter 16: Sharing Resources Between Timelines >  Page 809
</div>
<div class="noteText">
This lax behavior leads to surprizing bugs where a callback is expected to be called but isn't. For example, this can happen if an intermediate function doesn't pass the callback.

Calling undefined/null as is would probably be safer as it would at least fail instead of producing incorrect behavior.

It's definitely possible that this lax behavior is desirable for the system but this decision should be taken deliberately and the strict-behavior/principle-of-least-surprise should be the default.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 16: Sharing Resources Between Timelines >  Page 825
</div>
<div class="noteText">
With this change, now our update_total_queue will never grow longer than one unprocessed item, no matter how many we add or how fast we add them. The user will have to wait for at most two of the round trips to the server instead of all of them. This was a very small change to our queue code, resulting in a better behavior for our use case. Both queues are common enough that we will probably want to keep them around. What’s important is that we can use these queues as reusable concurrency primitives for other resources we need to share.
</div>
<div class="noteHeading">
Note - Chapter 16: Sharing Resources Between Timelines >  Page 826
</div>
<div class="noteText">
Reactive-extensions would probably do the same and much more both easily and in a safer manner.

Another simple and very effective approach is just to disable actions in the UI and restrict the user to only do one when the previous one is finished. This may even be better UX as it isn't possible for multiple slow actions to take minutes.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 17: Coordinating Timelines >  Page 860
</div>
<div class="noteText">
However, we can take advantage of JavaScript’s single thread and implement the primitive with a simple variable as long as we access it synchronously.
</div>
<div class="noteHeading">
Note - Chapter 17: Coordinating Timelines >  Page 860
</div>
<div class="noteText">
Do you mean "single-threaded model" and not "single thread."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 17: Coordinating Timelines >  Page 862
</div>
<div class="noteText">
Using Cut() in our code We’ve got our Cut() concurrency primitive, and we need to use it in our add to cart code. Luckily, the required change is fairly minimal. There are two things to figure out: What scope to store Cut() What the callback for Cut() is
</div>
<div class="noteHeading">
Note - Chapter 17: Coordinating Timelines >  Page 862
</div>
<div class="noteText">
I think there used to be a JS library called Async that has similar functions (concurrency primitives). It may not exist anymore as promises make this less necessary.

I think most modern event-loop implementations all use futures/promises and reactive-extensions can be very useful.

This presents a risk as it maybe a wrong, hard old technique (callback hell) that may never be used in the future instead of new techniques (promises/reactive-extensions) that are more robust and even more supported.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 17: Coordinating Timelines >  Page 864
</div>
<div class="noteText">
If you call it before the end, the timeline can continue on after the call to done(), which is not intended. It’s best to avoid that situation, because it can be confusing. The rule is to call done() at the end of the timelines you want to cut.
</div>
<div class="noteHeading">
Note - Chapter 17: Coordinating Timelines >  Page 864
</div>
<div class="noteText">
`done` should probably throw an error if called more times than intended. Especially that this can easily be catched as opposed to too few `done` calls.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 17: Coordinating Timelines >  Page 883
</div>
<div class="noteText">
An action that only has an effect the first time you call it is called idempotent. JustOnce() makes any action idempotent.
</div>
<div class="noteHeading">
Note - Chapter 17: Coordinating Timelines >  Page 883
</div>
<div class="noteText">
Idempotence is probably broader than that as it may include, for example, actions that can be retried safely.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 919
</div>
<div class="noteText">
If you need a stream of events instead of just one event, the ReactiveX (https:// reactivex.io) suite of libraries gives you the tools you need. Streams let you map and filter events. They have implementations for many different languages, including RxJS for JavaScript.
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 919
</div>
<div class="noteText">
They also help with composing (combining event resuts) and managing other events (e.g., mouse clicks). And much much more.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 919
</div>
<div class="noteText">
If you’re not really passing data through, it’s not really a pipeline. The reactive architecture might not be right.
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 919
</div>
<div class="noteText">
Not really sure. For example, reactive-extensions can be used with UI events even if you don't have much data.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 935
</div>
<div class="noteText">
The web handler’s job is to provide the cart by fetching it from the database. Thus, the same work is done, but in different layers. The fetching is done in the interaction layer and the summing in the domain layer.
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 935
</div>
<div class="noteText">
Should probably provide a rationale for fetching the cart instead of just the total from the DB as this choice is counterintuitive to most developers.
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 936
</div>
<div class="noteText">
Figure miniscule.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 936
</div>
<div class="noteText">
That’s
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 942
</div>
<div class="noteText">
var productsWithDiscounts = map( productsLastYear, function( product) { ❶ if(! product.discountID) return product; return objectSet( product, 'discount', db.fetchDiscount( product.discountID)); }); var reportLastYear = generateReport( productsWithDiscounts);
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 943
</div>
<div class="noteText">
You probably have an n+1 query here when using `fetchDiscount`. This should at least be noted.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 943
</div>
<div class="noteText">
Remember, it is always possible to build your domain out of calculations and cleanly separate the interaction layer from the domain layer.
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 943
</div>
<div class="noteText">
Definitely possible but can be very hard in many cases.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 18: Reactive and Onion Architectures >  Page 944
</div>
<div class="noteText">
Answer 1. L, 2. I, 3. I, 4. D, 5. D, 6. I, 7. L, 8. I.
</div>
<div class="noteHeading">
Note - Chapter 18: Reactive and Onion Architectures >  Page 944
</div>
<div class="noteText">
A detailed answer would be useful here.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 949
</div>
<div class="noteText">
But soon we build too high and they topple.
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 950
</div>
<div class="noteText">
Do you mean "we build them too high?"
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 952
</div>
<div class="noteText">
Typo
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 952
</div>
<div class="noteText">
ovn
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 960
</div>
<div class="noteText">
Elixir - Kotlin - Swift - Racket - Scala - Clojure - F# - Rust - Haskell** ** ordered roughly from easiest to hardest to get started with
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 960
</div>
<div class="noteText">
Would have expected Racket to be in the last three.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 960
</div>
<div class="noteText">
Native: Swift Via JVM: Scala - Kotlin Via Xamarin: F# Via React Native: ClojureScript - Scala.js
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 960
</div>
<div class="noteText">
Could make more sense to put Kotlin with native as projects using Kotlin are considered native in Android. And seeing officially supported Kotlin next to Scala and "via JVM" is just weird.

And Flutter/Dart seem to be missing. Especially that, at this time, it's 2.5 and has full support for Android, iOS, and web. And beta support for desktop.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 961
</div>
<div class="noteText">
Swift, Kotlin, and Racket have type systems, too, though they are less powerful.
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 961
</div>
<div class="noteText">
Indeed, Swift and Kotlin have less capable type-systems than the others.

But I don't think that Racket has much of a type-system. At least not a static one. It's probably in the same camp as Python.

I think it can be used with an optional static-typing system but optional-typing causes most of the code to not benefit from the types in practice.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 961
</div>
<div class="noteText">
Instead of encouraging you to define new types, these languages operate on a small number of data types and a large number of operations on them: Kotlin - Elixir - Clojure - Racket - Erlang**
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 961
</div>
<div class="noteText">
Scala and Rust have many operations for a small no. of data-container types too.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Chapter 19: The Functional Journey Ahead >  Page 962
</div>
<div class="noteText">
With concurrency primitives: Clojure - F# - Haskell - Kotlin Using the actor model: Elixir - Erlang - Scala Through the type system: Rust
</div>
<div class="noteHeading">
Note - Chapter 19: The Functional Journey Ahead >  Page 962
</div>
<div class="noteText">
Kotlin probably supports the actors-model right now either through some of its standard libraries or the Akka library.

And Rust unique advantages (e.g., detecting some race-conditions at compile-time) go unmentioned here.
</div>

        </div>
    </body>
</html>
