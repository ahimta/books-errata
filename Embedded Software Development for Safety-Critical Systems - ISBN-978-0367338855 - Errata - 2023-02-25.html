<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                              "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en"
	lang="en">
	<head>
                <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
                <!-- HTML5 -->
                <meta charset="UTF-8"/>
		<style type="text/css">
                    .bodyContainer {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    padding-left: 32px;
    padding-right: 32px;
}

.notebookFor {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin: 24px 0px 0px;
    padding: 0px;
}

.bookTitle {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    padding: 0px;
}

.authors {
    font-size: 13px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin-top: 22px;
    margin-bottom: 24px; 
    padding: 0px;
}

.citation {
    font-size: 16px;
    font-weight: 500;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    margin-bottom: 24px;
    padding: 0px;
}

.sectionHeading {
    font-size: 24px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 24px;
    padding: 0px;
}

.noteHeading {
    font-size: 18px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 20px;
    padding: 0px;
}

.noteText {
    font-size: 18px;
    font-weight: 500;
    text-align: left;
    color: #333333;
    margin: 2px 0px 0px;
    padding: 0px;
}

.highlight_blue {
    color: rgb(178, 205, 251);
}

.highlight_orange {
    color: #ffd7ae;
}

.highlight_pink {
    color: rgb(255, 191, 206);
}

.highlight_yellow {
    color: rgb(247, 206, 0);
}

.notebookGraphic {
    margin-top: 10px;
    text-align: left;
}

.notebookGraphic img {
    -o-box-shadow:      0px 0px 5px #888;
    -icab-box-shadow:   0px 0px 5px #888;
    -khtml-box-shadow:  0px 0px 5px #888;
    -moz-box-shadow:    0px 0px 5px #888;
    -webkit-box-shadow: 0px 0px 5px #888;
    box-shadow:         0px 0px 5px #888; 
    max-width: 100%;
    height: auto;
}

hr {
    border: 0px none;
    height: 1px;
    background: none repeat scroll 0% 0% rgb(221, 221, 221);
}

		</style>
		<script type="text/javascript">
		    
		</script>
		<title></title>
	</head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
Notebook for
</div>
<div class="bookTitle">
Embedded Software Development for Safety-Critical Systems, Second Edition
</div>
<div class="authors">
Hobbs, Chris
</div>
<div class="citation">
Citation (Chicago Style): Hobbs, Chris. <i>Embedded Software Development for Safety-Critical Systems, Second Edition</i>. CRC Press, 2019. Kindle edition.
</div>
<hr />

            <div class="sectionHeading">
Title Page
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) -  Page iii
</div>
<div class="noteText">
Embedded Software Development for Safety-Critical Systems Second Edition 
</div>
<div class="noteHeading">
Note -  Page iii
</div>
<div class="noteText">
Title page repeated in the 2nd previous page.
</div>
<div class="sectionHeading">
Dedication
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) -  Page v
</div>
<div class="noteText">
For Alexander, Thomas, and Edward ' ' , '    
</div>
<div class="noteHeading">
Note -  Page v
</div>
<div class="noteText">
Is the non-English (seems Hebrew) part intentional?
</div>
<div class="sectionHeading">
Preface
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Second Edition >  Page xv
</div>
<div class="noteText">
In general, I refer to open-source tools, not because these are always superior to commercial equivalents, but because it would be invidious to mention one commercial vendor rather than another unless I had carried out a careful comparison of the available products. 
</div>
<div class="noteHeading">
Note - Second Edition >  Page xv
</div>
<div class="noteText">
There's also that it's much easier to learn and start up with open-source tools using their full feature-set.

Commercial tools can take weeks just to get a price quote.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Second Edition >  Page xv
</div>
<div class="noteText">
I refuse to take the bait in these discussions, comfortable in my knowledge that vi is far better than emacs. 
</div>
<div class="noteHeading">
Note - Second Edition >  Page xv
</div>
<div class="noteText">
Very true!
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Acknowledgments >  Page xvi
</div>
<div class="noteText">
problems arising from accidental system and problems arising from machine learning. 
</div>
<div class="noteHeading">
Note - Acknowledgments >  Page xvi
</div>
<div class="noteText">
Do you mean "accidental system complexity" or "accidental systems?"
</div>
<div class="sectionHeading">
Section I: Background
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 1. Introduction >  Page 5
</div>
<div class="noteText">
As Les Chambers said in his blog in February 2012‚Ä†
</div>
<div class="noteHeading">
Note - 1. Introduction >  Page 5
</div>
<div class="noteText">
All URLs should probably use HTTPS wherever possible.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 1. Introduction >  Page 10
</div>
<div class="noteText">
Today almost every electronic device supports external communications through Wi-Fi, Bluetooth, USB drives, or from GPS satellites, and these channels are all security vulnerabilities. 
</div>
<div class="noteHeading">
Note - 1. Introduction >  Page 10
</div>
<div class="noteText">
Describing the communication channels as "security vulnaribilities" with this wording and without any qualifications seems a bit off.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 2. Terminology of Safety >  Page 21
</div>
<div class="noteText">
Commission Regulation (EC) No 482/2008
</div>
<div class="noteHeading">
Note - 2. Terminology of Safety >  Page 21
</div>
<div class="noteText">
Do you mean "ER" here instead of "EC?"
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 2. Terminology of Safety >  Page 23
</div>
<div class="noteText">
For this reason, research has been carried out (e.g., reference [4]) on ways to convert Bohrbugs into Heisenbugs.
</div>
<div class="noteHeading">
Note - 2. Terminology of Safety >  Page 23
</div>
<div class="noteText">
Should probably explain this point further as it still seems counterintuitive.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 2. Terminology of Safety >  Page 23
</div>
<div class="noteText">
The elusive nature of Heisenbugs make them particularly difficult to fix, and some researchers, particularly Andrea Borr (see, for example, reference [5]), have found that attempts to fix Heisenbugs generally make the situation worse than it was before. 
</div>
<div class="noteHeading">
Note - 2. Terminology of Safety >  Page 23
</div>
<div class="noteText">
Could be useful to mention some simple but very effective approaches for working with Heisenbugs.

For example, running the suspect part of the system 10s, 100s or more. This can be non-trivial but still more productive and less stressful than other techniques. This technique cost can also be amoterized over many tricky bugs.

But, in the end, the single most powerful technique is probably to cool down and assume a simple Bohrbug and only go the Heisenbug route as a last resort.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 3. Safety Standards and Certification >  Page 37
</div>
<div class="noteText">
Two types of safety system are considered: 
</div>
<div class="noteHeading">
Note - 3. Safety Standards and Certification >  Page 37
</div>
<div class="noteText">
Typo: "two types of safety system."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 3. Safety Standards and Certification >  Page 38
</div>
<div class="noteText">
However, in order to make use of these hours of operation, it would be necessary to know the numbers of failures, and these might be difficult to obtain.
</div>
<div class="noteHeading">
Note - 3. Safety Standards and Certification >  Page 38
</div>
<div class="noteText">
Let alone simple statistics, there are numorous factors here.

For example, 10K hours of operation on a single car maybe completely different from 2 hours on 5K cars.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 3. Safety Standards and Certification >  Page 46
</div>
<div class="noteText">
However, if its learning is fixed at manufacturing time and thereafter only updated on a maintenance cycle, dangerous behavior could persist in the device for a long time. 
</div>
<div class="noteHeading">
Note - 3. Safety Standards and Certification >  Page 46
</div>
<div class="noteText">
And it maybe ill-trained for the user current environment or become so for the future environment.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 3. Safety Standards and Certification >  Page 50
</div>
<div class="noteText">
Thus, strong processes need to be enforced during the development of a product, not because that will ensure that the product is of good quality, but because, without strong processes, we cannot trust any of the information we need to produce our safety case. 
</div>
<div class="noteHeading">
Note - 3. Safety Standards and Certification >  Page 50
</div>
<div class="noteText">
Very well said!
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 4. Representative Companies >  Page 54
</div>
<div class="noteText">
(SOUP). 
</div>
<div class="noteHeading">
Note - 4. Representative Companies >  Page 54
</div>
<div class="noteText">
Would be nice for the acronym to be "SoUP" and the same goes for "SotIF" instead of "SOTIF". This helps emphazise the main words and de-emphasize prepositions.
</div>
<div class="sectionHeading">
Section II: The Project
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 5. Foundational Analyses >  Page 60
</div>
<div class="noteText">
In requirements, words like SHALL, MUST, MUST NOT, MAY are often capitalized in accordance with RFC2119 (reference [1]). This avoids having to define the meanings of those words in each requirements document. 
</div>
<div class="noteHeading">
Note - 5. Foundational Analyses >  Page 60
</div>
<div class="noteText">
It's only mentioned here that they're capitalized but the meaning being used should probably be mentioned explicitly instead of implicitly in the following sentence.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 5. Foundational Analyses >  Page 73
</div>
<div class="noteText">
Having and intelligent adversary implies that security threats will evolve and adapt. 
</div>
<div class="noteHeading">
Note - 5. Foundational Analyses >  Page 73
</div>
<div class="noteText">
Typo: "Having and intelligent advisory."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 6. Certi ed and Uncerti ed Components >  Page 87
</div>
<div class="noteText">
1. Route 1S: development compliant with IEC 61508. 2. Route 2S: proven-in-use (PIU). 3. Route 3S: assessment of a noncompliant development. 
</div>
<div class="noteHeading">
Note - 6. Certi ed and Uncerti ed Components >  Page 87
</div>
<div class="noteText">
What's with the "S" subscript suffixes?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 6. Certi ed and Uncerti ed Components >  Page 90
</div>
<div class="noteText">
could take significant time.
</div>
<div class="noteHeading">
Note - 6. Certi ed and Uncerti ed Components >  Page 90
</div>
<div class="noteText">
How much time? As different readers may understand this drastically differently.

And I see no mention of version/environment as they can make or break safety.
</div>
<div class="sectionHeading">
Section III: Design Patterns
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 7. Architectural Balancing >  Page 99
</div>
<div class="noteText">
at least until the drivers lose patience and start to ignore them. 
</div>
<div class="noteHeading">
Note - 7. Architectural Balancing >  Page 99
</div>
<div class="noteText">
Excellent point! It also highlights non-technical factors (and implicitly regional/environmental factors) that are just as important.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 7. Architectural Balancing >  Page 103
</div>
<div class="noteText">
cacheing
</div>
<div class="noteHeading">
Note - 7. Architectural Balancing >  Page 103
</div>
<div class="noteText">
I usually see "caching" and can't recall seeing "cacheing" before.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 105
</div>
<div class="noteText">
Law Number XVIII: It is very expensive to achieve high unreliability. It is not uncommon to increase the cost of an item by a factor of ten for each factor of ten degradation accomplished. 
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 105
</div>
<div class="noteText">
Very wise but still probably confusing and counterintuitive to many people and warrants some explanation.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 106
</div>
<div class="noteText">
Annex E re¬®ƒ±terates the idea
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 106
</div>
<div class="noteText">
The non-English "i" looks like a typo.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 106
</div>
<div class="noteText">
two different types of algorithm
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 106
</div>
<div class="noteText">
Probably a typo where "algorithm" used instead of "algorithms."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 106
</div>
<div class="noteText">
such as occur
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 106
</div>
<div class="noteText">
The "such as occur" wording doesn't seem right.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 113
</div>
<div class="noteText">
An array indexed by a value other than an integer.
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 113
</div>
<div class="noteText">
Maybe more accurate that not all entries up to max-index necessarily stored.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
to a acceptable result.
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
Seems like a typo: "a" when "an" should be used.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
By definition, the precise conditions needed to provoke the Heisenbug are unlikely to recur. 
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
This depends on the Heisenbug. For example, the situation may be aggraviated with livelocks.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
One disadvantage of recovery blocks is that any side effects (system changes) made by a routine whose output is eventually rejected by the acceptance routine must be undone before the computation is repeated. 
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
This isn't always easy but each function should only change system state iff successful and revert changes if failing.

This can make some functions relatively complex but simplifies the overall function. And the function itself should know best how to revert system changes anyway.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
In fact, I have included it in Chapter 10 on page 157 as a form of replication. 
</div>
<div class="noteHeading">
Note - 8. Error Detection and Handling >  Page 128
</div>
<div class="noteText">
Not clear why it's put in replication. And it'd be helpful to use a hyperlink here.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 9. Expecting the Unexpected >  Page 134
</div>
<div class="noteText">
However, I have tried to include it where possible in the IEC 61508 calculation because, even though the larger system should be designed to handle a component moving to its design safe state, such moves will always place stress on the larger system and move it closer to a dangerous condition. 
</div>
<div class="noteHeading">
Note - 9. Expecting the Unexpected >  Page 134
</div>
<div class="noteText">
Very well said!
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 9. Expecting the Unexpected >  Page 135
</div>
<div class="noteText">
Do You Want to Recover? 
</div>
<div class="noteHeading">
Note - 9. Expecting the Unexpected >  Page 135
</div>
<div class="noteText">
Can't really emphasize this enough and such insights that can't be put in a particular chapter should probably have a chapter of their own.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 9. Expecting the Unexpected >  Page 137
</div>
<div class="noteText">
When a user presses a button, the window should start to close. If it detects resistance to closing (such as the presence of a child‚Äôs hand or neck), it should stop.
</div>
<div class="noteHeading">
Note - 9. Expecting the Unexpected >  Page 137
</div>
<div class="noteText">
Another viable alternative to have the closing force so low that it can't harm a human and thus design the issue out of the system.

But this have the adverse effect of lulling the user into false safety with a product and being maimed by a different product in the market and how the ecosystem handles this should be taken into account.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 10. Replication and Diversification >  Page 154
</div>
<div class="noteText">
If server instance 1 loses contact with the other instances, it is impossible for those other instances to determine whether this is because instance 1 has crashed or because, even though it is still running, communications to it have been lost. 
</div>
<div class="noteHeading">
Note - 10. Replication and Diversification >  Page 154
</div>
<div class="noteText">
Should probably mention a relevant technical term (e.g., split-brain).
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 10. Replication and Diversification >  Page 155
</div>
<div class="noteText">
Another algorithm for maintaining agreement on group membership in the face of unreliable nodes is Leslie Lamport‚Äôs PAXOS described in reference [14]
</div>
<div class="noteHeading">
Note - 10. Replication and Diversification >  Page 155
</div>
<div class="noteText">
There's also RAFT and another consensus (should probably mention this technical term) algorithm that looks even more processing and is used by Fauna Labs.

The Kafka project also have had a great recent experience with RAFT.

Most important is that Paxos is infamous for being very hard to implement and get right and probably should be deprecated (if not already).
</div>
<div class="sectionHeading">
Section IV: Design Validation
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 12. The Fault Tree >  Page 174
</div>
<div class="noteText">
It might be convenient to express the condition that entering a wrong dosage causes a system failure in 90% of cases (this number having been obtained through experiments across several hospitals). 
</div>
<div class="noteHeading">
Note - 12. The Fault Tree >  Page 174
</div>
<div class="noteText">
This, unfortunately, could mean that this statistic isn't representative of any one hospital using the system.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 12. The Fault Tree >  Page 185
</div>
<div class="noteText">
With AgenaRisk, in contrast, there is no published application programming interface (API) for the calculation engine; everything has to be entered using the graphics editor. This is one area where I have never found a really good open-source alternative to the commercial tools. 
</div>
<div class="noteHeading">
Note - 12. The Fault Tree >  Page 185
</div>
<div class="noteText">
APIs/code have many other advantages too. For example, it's much easier to version-control/review.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 13. Software Failure Rates >  Page 187
</div>
<div class="noteText">
with a simple run-to-completion executives 
</div>
<div class="noteHeading">
Note - 13. Software Failure Rates >  Page 187
</div>
<div class="noteText">
Do you mean "executable?"
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 13. Software Failure Rates >  Page 187
</div>
<div class="noteText">
rather than a re-entrant operating systems.
</div>
<div class="noteHeading">
Note - 13. Software Failure Rates >  Page 187
</div>
<div class="noteText">
This seems to be related to cooperative/preemptive designs and if so mentioning these terms would probably be helpful to readers.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 13. Software Failure Rates >  Page 188
</div>
<div class="noteText">
I convinced him that he was wrong and the editor suggested that he submit a ‚ÄúLetter to the Editor,‚Äù which I could then refute. He declined to expose his mistake. 
</div>
<div class="noteHeading">
Note - 13. Software Failure Rates >  Page 188
</div>
<div class="noteText">
You seem to have quite the confrontational style. We probably need more people like this in this age where agreeableness abound.

However, IMHO, this straight-arrow style, although right, can backfire in the future and hurt in the long run and tempering one's word maybe of atmost importance.

You probably can agree with this in firsthand by how you feel right now while reading this note that isn't even that confrontational.

A wise man once said, paraphrasing here, "A single enemy is too many."

And finally, it may be argued that this anecdote, although not naming names, shouldn't be as seemingly-accurate/judgemental as mentioned parties can't defend themselves here.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 13. Software Failure Rates >  Page 189
</div>
<div class="noteText">
It can be argued that the program in Figure 5.4 contains a bug. I agree, the programmer should have protected the global variable x with a mutex. But every program we ship contains bugs and we should be modeling reality rather than a perfect world where we never ship Heisenbugs. 
</div>
<div class="noteHeading">
Note - 13. Software Failure Rates >  Page 189
</div>
<div class="noteText">
Very well said! As one quote says, paraphrasing here, "In theory practice doesn't matter, but in practice, it does."

I don't recall the book mentioning Rust and suspect it doesn't. But I think there's a strong argument to be made for handling as many concerns (e.g., some race-coditions at compile-time) in infrastructure. C/C++ can be thought of as some sort of heroics magnet.

One huge issue with C/C++ is that it's inherently unsafe that's, even with all the static/dynamic analysis tools, significant risk will always remain. And even if said risk were theoretically eliminated, seemingly trivial changes can reintroduce them.

This is relevant to a principle of mine: no amount of human effort can beat a computer for tasks (e.g., safer compilers/lantuages like Rust) that are tractable for computers and they're superior at.

This doesn't mean that Rust is always superior to C/C++ especially that the latter issues/risks are much more understood.

I'd close with this: maybe we should start thinking of languages' typesystems/safety along the same lines of their ability to handle syntax errors. For example, is it any different for someone to use C/C++ over Rust than using a programming language without a syntax checker over one with a syntax checker?!
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 13. Software Failure Rates >  Page 196
</div>
<div class="noteText">
Figure 13.2 Estimating the software defects. 
</div>
<div class="noteHeading">
Note - 13. Software Failure Rates >  Page 196
</div>
<div class="noteText">
Could be useful to use the same scale, at least for comparable graphs. As otherwise the graphs are quite deceptive in relation to each other.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 14. Semi-Formal Design Verification >  Page 201
</div>
<div class="noteText">
Rebuilding the ‚Äúdesign‚Äù that has actually been implemented from the implementation and comparing that with the intended design, as illustrated in Figure 14.1, can then be useful in closing the loop. 
</div>
<div class="noteHeading">
Note - 14. Semi-Formal Design Verification >  Page 201
</div>
<div class="noteText">
Preferably with the help of code visualization tools. Even Doxygen alone can be surprizingly useful.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 225
</div>
<div class="noteText">
Since those early days, these languages, and many others, have been enhanced, particularly in the areas of proving algorithms, and practical tools have become available. 
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 225
</div>
<div class="noteText">
Not really sure but Coq maybe included here too.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 228
</div>
<div class="noteText">
I was a na¬®ƒ±f engineer.
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 228
</div>
<div class="noteText">
Typo: "na√Øf."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 228
</div>
<div class="noteText">
The moral of the story is that, even though engineers want unambiguous requirements, and the standards encourage this, it may not always be commercially acceptable. 
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 228
</div>
<div class="noteText">
It's also impractical in the sense that a simple feature that seems simple may turn out to be prohibitively expensive or unsolvable (at least in the specified state).
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 230
</div>
<div class="noteText">
and because they are available as open-source, meaning that the reader can experiment with them at no cost and can, if necessary, extend the tool. 
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 230
</div>
<div class="noteText">
These very important points are often missed.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 233
</div>
<div class="noteText">
As the algorithm contains an error, I will not provide a reference to the paper, but I will say that the journal in which it was published was, and is, prestigious. 
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 233
</div>
<div class="noteText">
Seems a bit strange that the paper isn't referenced and this may detract from the objectivity of the book.

We all make mistakes and should contribute to spreading this culture.

I understand that the author may not want to reference the paper to avoid making enemies but the paper is just too old for its author to care that much.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 235
</div>
<div class="noteText">
Converting this program to Promela is straightforward, and an assert(x != 5) statement immediately before the printf() quickly produces the sequence of events that will lead to a division by zero. 
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 235
</div>
<div class="noteText">
What `printf`? I coudn't find it anywhere and this seems deliberate. And showing the actual C code here would be very useful.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 15. Formal Design Verification >  Page 245
</div>
<div class="noteText">
Anecdote 24 The fear of the mathematics is real. I once presented some of these formal methods to a group of programmers and one programmer said to me afterwards, ‚ÄúI went into programming so that I wouldn‚Äôt have to do maths.‚Äù He may have been joking. 
</div>
<div class="noteHeading">
Note - 15. Formal Design Verification >  Page 245
</div>
<div class="noteText">
This is a bit sad as programming is merely a tool, just like formal methods, and whatever produces the better end result should be used.

Otherwise, the means would justify the ends!
</div>
<div class="sectionHeading">
Section V: Coding
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 251
</div>
<div class="noteText">
Also we are victims of our drive for efficiency‚Äî for most (non-safety) applications we would prefer our languages to be easily optimized for space or speed than for being easily demonstrated correct.
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 251
</div>
<div class="noteText">
And sadly supposedly optimized code maybe slower, everywhere, in some production environments, when compilers optimize for the simpler code, and many other cases.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 254
</div>
<div class="noteText">
With testing becoming less effective with the increase in the size of the state space of programs, static checking is becoming more important. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 254
</div>
<div class="noteText">
Automated testing is also very useful and can have a very high ROI but projects miss the point when they under do it or over do it and not choose the right point in the spectrum.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 255
</div>
<div class="noteText">
For the GNU C compiler, a vast history of usage and error reports exist; for other languages, such as D and RUST, that level of ‚Äúconfidence from use‚Äù may not yet be available. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 255
</div>
<div class="noteText">
Excellent point!
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 255
</div>
<div class="noteText">
The equivalent program in C compiles and executes without an error message because C is weakly typed: int main() { printf("%s\n", "5"+6); return 0; } 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 255
</div>
<div class="noteText">
True but still depends on project quality control which may range from not using many diagnostics to having all possible diagnostics and treating warnings as errors and more.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 256
</div>
<div class="noteText">
Dynamic typing allows code to be more compact and, in particular, to have fewer conditional statements. Conditional statements are the source of additional test cases, and, empirically, it has been found that conditional statements are the most likely types of statements to contain faults. It can be argued that avoiding them by using a language with dynamic typing is worthwhile. The standards, however, look for both strong and static typing, so the use of a language with dynamic typing would have to be justified. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 256
</div>
<div class="noteText">
Not having conditionals doesn't mean not having their cases/scenarios.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 256
</div>
<div class="noteText">
A language which allows common errors to be found at compilation time is to be preferred. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 256
</div>
<div class="noteText">
Rust truly excels in this regard.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
For example, it could be argued that a language within which if ((x = 16)) {printf("Hello\n");} is syntactically correct but does not mean ‚Äúif x is equal to 16 print Hello‚Äù is perhaps unsuitable for dependable applications. With the double brackets around x = 16, this line does not even generate a compiler warning with the -Wall option on the gcc version 4.9.4 compiler. As I put the second edition of this book to bed, I have just spent an hour tracing an obscure bug in a large C system which turned out to be an erroneous semi-colon buried deep in the code: if (oldValue == *v); {return 0;} 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
This is related to using many diagnostics and different compilers and static-analysis tools and having a culture of learning why diagnostics are emitted and minimizing this so they can be taken seriously and suppressed in rare occasions as appropriate.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
Another common programming error, particularly when modifying existing code, is inadvertently to alter the value of a loop counter within the loop. To prevent this, Ada makes loop variables read-only within the loop and undefined outside the loop. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
Loop counters are a call for disaster as multiple things have to be done right which introduces unnecessary risk.

Some of the things you have to ensure are correct are the following:
1. Index manipulated correctly.
2. Correct variable/array/pointer used.
3. Correct combination of the above used correctly (more error-prone with nested loops).

Add to this the confusing cargo-cult behavior of avoiding mixed-declarations with C99+ and using i/j with multi-level instead of meaningful index-variable names.

Rust handles this well with its iterators that make using indexes unnecessary even for cases where continue/break are needed.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
The D programming language allows a function to be marked as @safe. When this is done, the compiler prevents the use of instructions which may not be memory-safe, such as casting from a pointer type to any type other than void*, pointer arithmetic, taking the address of a local variable or function parameter and using void initializers for pointers. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
This is a bit strange of a lax behavior. A system/language should be safe by default and parts that are unsafe should be marked as so.

This is security/reliability 101 where `write()` should be safe and `write_unsafe()`. Otherwise, you'd always have to do extensive research to guarantee safety. And even then by virtue of unsafe by default, the safe parts can become unsafe silently.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
The safety standards do not encourage recursion, the basis of functional programming, because of the possibility of stack overflow.
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 257
</div>
<div class="noteText">
Recursion doesn't necessarily mean stack-space. For example, Prof. Greg Kicsales of UBC shows how to turn any recursive function tail-recursive and Haskell probably has many similar techniques.

Probably the biggest issue is time-space leaks and other complications due to lazy-evaluation.

And strong linking of FP and recursion is a misconception. And recursion is the goto of FP as mentioned by Erik Meijer.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 16. Coding Guidelines >  Page 260
</div>
<div class="noteText">
In some applications, integer arithmetic, floating slash or interval arithmetic might be better approaches than floating point. 
</div>
<div class="noteHeading">
Note - 16. Coding Guidelines >  Page 260
</div>
<div class="noteText">
Integer/fixed arithmetic is very effective and simple to implement for many usecases. FP numbers are overrated and many programmers' brains are unfortunately wired to use them.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 17. Code Coverage Metrics >  Page 262
</div>
<div class="noteText">
This is good defensive coding, protecting against a programmer adding an extra color to the enum later and forgetting to update this switch statement.
</div>
<div class="noteHeading">
Note - 17. Code Coverage Metrics >  Page 262
</div>
<div class="noteText">
There are compiler diagnostics for this. And using a default can make it impossible for the compiler to detect uncovered cases (esp., when new values added).
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 17. Code Coverage Metrics >  Page 266
</div>
<div class="noteText">
The original limit of 10 as proposed by McCabe has significant supporting evidence, but limits as high as 15 have been used successfully as well. Limits over 10 should be reserved for projects that have several operational advantages over typical projects, for example experienced staff, formal design, a modern programming language, structured programming, code walkthroughs, and a comprehensive test plan. In other words, an organization can pick a complexity limit greater than 10, but only if it is sure it knows what it is doing and is willing to devote the additional testing effort required by more complex modules. 
</div>
<div class="noteHeading">
Note - 17. Code Coverage Metrics >  Page 266
</div>
<div class="noteText">
One could argue that much of the art of programming is achieved by writing simple modules that can represent complex systems in the real world.

There are certainly cases an incredibly complex module can simplify the rest of the system, but this can be a slippery slope and lead to great complexity with much more harm than good which can cause compex ancillary features to break the critical required features.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 275
</div>
<div class="noteText">
This is unfortunately impossible. In the first case, it is impossible to specify what a program ought to do. Consider this snippet of C code and ask yourself whether it contains a fault: int y = 10; char x[8]; int z = 7; strcpy(x, "12345678"); Almost all programmers, and all static analysis tools, will immediately claim that there is a fault in the code: a beginner‚Äôs fault. The program copies 9 bytes (the 8-byte string ‚Äú12345678‚Äù and its terminating zero) to a field only 8 bytes wide. Depending on how the compiler has laid out the stack, either y or z will be corrupted. This is true, but the purpose of the program was to allow the programmer to test an application for detecting and handling stack corruption‚Äî the program is doing exactly what it is intended to do in deliberately corrupting the stack. Without a formal definition of what the program is intended to do, it is impossible for either a human or a program to determine whether it is correct or not, and, generally, the only formal definition is the program itself. 
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 275
</div>
<div class="noteText">
This is, in a sense, perfect being the enemy of good. In the end, all checking is imperfect and unsafe and questionable operations, even if correct, will trip up all kinds of warnings/errors.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 277
</div>
<div class="noteText">
In summary, they found that only about 9% of the warnings given by the lint-like tools pointed to code that was changed as a result of bug fixing during the first one to four years of operation.
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 277
</div>
<div class="noteText">
There's still great benefit to writing code in a way that doesn't trip up analyzers and making warnings as errors.

Because, otherwise, 1% of warnings that can fail a system in weird scenarios can be buried in trivial warnings. This may even be an understatement as a machine can beat a world-class expert in syntactic/pedantic analysis.

And so error/warning free code (with suppressions where it's impractical) should be a baseline and, as a programmer practice this, their coding style changes and adapts to writing visibly correct code that machines can't complain about, humans don't need explanations for, and doesn't depend on far/global parts of a system to be correct or do things in a certain way that can easily change.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 278
</div>
<div class="noteText">
int doit(const char * const string, const int length) { int i = 0; int j = 0; for (i=0; i<length; i++) { if (string[i] == NULL) return 0; else j += 1; } return j; } Figure 18.1 A program with a fault. Coccinelle‚Ä† is a very useful tool, because it not only detects transgressions in the code, but can be scripted to produce diff files to correct the problems. For example, given the program in Figure 18.1, Coccinelle will, if provided with the appropriate script, create the following diff to correct the problem: - if (string[i] == NULL) + if (string[i] == ‚Äô\0‚Äô) 
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 278
</div>
<div class="noteText">
This should easily caught by the compiler with proper diagnostics.

There's also an additional issue where `string` itself not checked against `NULL` and assertion (that runs on production too) should probably be used here.

It's always nice to see someone using `* const` and more so `* const restrict`. And it could be useful to do `char const * const` (`const` applies to the type before and only the one after if it's first in declaration).
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 280
</div>
<div class="noteText">
Anecdote 27 My colleague Patrick Lee once used this Coccinelle script to demonstrate that a large codebase did not include recursion. It demonstrated that the only recursion in the product was tailrecursion. He then justified to his auditor the use of tail-recursion on the grounds that it met the requirements of paragraph C.2.6.7 of IEC 61508-7: ‚ÄúIf recursion is used, there must be a clear criterion which makes predictable the depth of recursion.‚Äù This is obviously true for tail-recursion. 
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 280
</div>
<div class="noteText">
This is probably the case for all recursive functions iff their inputs and data-structures are validated against an upper bound and then the stack size calculated for this upper bound.

I don't see any mention of optimizing compilers where tail-recursion is assumed to be equivalent to a loop and this seems to be implied here but should probably be mentioned explicitly in either case.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 281
</div>
<div class="noteText">
An example of these (and other) factors being used to predict the risk associated with releasing a new version of a software system is provided in reference [4] by Audris Mockus and David Weiss. 
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 281
</div>
<div class="noteText">
Adam Tornhil seems to focus on this area too.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 283
</div>
<div class="noteText">
int doit(unsigned x)// x is in the range 0 to 4294967295 { unsigned y;// y is in the range 0 to 4294967295 if (x > 256) { y = x/ 2;// x is in the range 257 to 4294967295 // y is in the range 128 to 2147483647 } else { y = x/ 3;// x is in the range 0 to 256 // y is in the range 0 to 85 } return y; } 
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 283
</div>
<div class="noteText">
Why is `unsigned` used instead of the more clear equivalent `unsigned int`?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 18. Static Analysis >  Page 286
</div>
<div class="noteText">
B. Livshits, M. Sridharan, Y. Smaragdakis, O. Lhot¬¥ak, J. N. Amaral, B.- Y. E. Chang, S. Z. Guyer, U. P. Khedker, A. M√∏ller, and D. Vardoulakis, ‚ÄúIn Defense of Soundiness: A Manifesto,‚Äù
</div>
<div class="noteHeading">
Note - 18. Static Analysis >  Page 286
</div>
<div class="noteText">
Typo: "soundiness."
</div>
<div class="sectionHeading">
Section VI: Verification
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 19. Integration Testing >  Page 302
</div>
<div class="noteText">
The message of combinatorial testing is clear: If the number of combinations of parameters makes a full test suite impractical, then the subset of test cases that it is useful to run can be chosen scientifically to provide good coverage. This subset is almost certainly better than any subset chosen, effectively at random, by a tester. 
</div>
<div class="noteHeading">
Note - 19. Integration Testing >  Page 302
</div>
<div class="noteText">
There are very crucial points not mentioned about combanitorial testing. Some of them are the following:
1. Are the options/variability really necessary/sane and is it impractical for the system to only have a fixed no. of configurations? Fixed configurations can also make the product usable for many clients.
2. A golden set of configurations can always be tested.
3. The product can run tests for configurations once they are used and maybe even give clients the ability to test arbitrary configurations.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 20. The Tool Chain >  Page 316
</div>
<div class="noteText">
Even the snippet of code illustrated in Figure 20.1, which looks very trivial, should never have passed code inspection because it violates most C coding standards (including MISRA-C 2012, rule 10.4) in directly comparing a signed to an unsigned variable. 
</div>
<div class="noteHeading">
Note - 20. The Tool Chain >  Page 316
</div>
<div class="noteText">
This is a serious mistake (comparing signed and unsigned types) that even projects that don't use any coding-standard should avoid.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 20. The Tool Chain >  Page 316
</div>
<div class="noteText">
This needs to be handled very subtly, because the certificates themselves, being produced by an untrustworthy compiler, cannot be trusted either.
</div>
<div class="noteHeading">
Note - 20. The Tool Chain >  Page 316
</div>
<div class="noteText">
This is probably an example of where checking whether a result is correct/reasonable can be much easier than producing a correct/reasonable result.

And a compiler can leverage this against its produced results. This, of course, depends on many factors that can make it very trivial in cases but almost impossible in others.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - 20. The Tool Chain >  Page 316
</div>
<div class="noteText">
References [2] and [4] by Marcus Bortel and me
</div>
<div class="noteHeading">
Note - 20. The Tool Chain >  Page 316
</div>
<div class="noteText">
Now you admit being an academic over halfway through the book!
</div>
<div class="sectionHeading">
Section VII: Appendices
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix A: Goal Structuring Notation >  Page 327
</div>
<div class="noteText">
The GSN‚Ä†
</div>
<div class="noteHeading">
Note - Appendix A: Goal Structuring Notation >  Page 327
</div>
<div class="noteText">
I probably mentioned this before but why are URLs using HTTP instead of HTTPS?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix A: Goal Structuring Notation >  Page 327
</div>
<div class="noteText">
In summary, the graphical symbols are as follows: 
</div>
<div class="noteHeading">
Note - Appendix A: Goal Structuring Notation >  Page 327
</div>
<div class="noteText">
It would be very useful/convenient to have symbols with their explanations rather than just using words.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix A: Goal Structuring Notation >  Page 331
</div>
<div class="noteText">
And so on. This approach allows anyone on the team to express disquiet about something he or she has noticed during the development. This encourages the questioning and reporting attitudes required for a good safety culture (see page 4). Simply turning a question from ‚ÄúIs this system ready for release?‚Äù into ‚ÄúCan you think of any reason why this system is not ready for release?‚Äù allows an engineer to express concern in a constructive way. At the time of writing, I am working with the group evolving GSN to incorporate inductive argumentation into version 4 of the standard. 
</div>
<div class="noteHeading">
Note - Appendix A: Goal Structuring Notation >  Page 331
</div>
<div class="noteText">
Important to mention other crucial factors like culture. I think the Checklist Manifesto book talks about such aspects using a Korean Airline casestudy.

The importance of this can't be understated. And for technical consultants I say: if your goal is to preach technical excellence to clients, by all means do. But if your goal is for your clients to achieve technical excellence, or even better achieve outcomes technical excellence is a means for, then you should focus on this and use anything and everything as a leverage.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix B: Bayesian Belief Networks >  Page 339
</div>
<div class="noteText">
Figure B.4 A fragment of a safety case argument. 
</div>
<div class="noteHeading">
Note - Appendix B: Bayesian Belief Networks >  Page 339
</div>
<div class="noteText">
The figure alignment is perpendicular to the page. Is this intentional?

I think applies to other figures too.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix B: Bayesian Belief Networks >  Page 340
</div>
<div class="noteText">
Figure B.5 illustrates the a posteriori probabilities when the analyst has studied the actual project. 
</div>
<div class="noteHeading">
Note - Appendix B: Bayesian Belief Networks >  Page 340
</div>
<div class="noteText">
Should probably briefly explain "a posteriori" and maybe even contrast it with "a priori" as it's very little bother to those who know and very convenient for those who don't.

And, in general, it's super nice for books to be standalone, wherever practical.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix B: Bayesian Belief Networks >  Page 342
</div>
<div class="noteText">
BBN or GSN for a Safety Case? 
</div>
<div class="noteHeading">
Note - Appendix B: Bayesian Belief Networks >  Page 342
</div>
<div class="noteText">
A well-written, comparative, and simple analysis. It's quite impressive an example to be followed.

The "My Choice" section, however, seems quite hurried and lacking. Which is not so uncommon with you author folk at the end of a book.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix B: Bayesian Belief Networks >  Page 342
</div>
<div class="noteText">
Suitably anonymized, the data from the BBNs could be fed back to improve the priors. 
</div>
<div class="noteHeading">
Note - Appendix B: Bayesian Belief Networks >  Page 342
</div>
<div class="noteText">
Would be nice to explain "priors" here briefly. Just like "a posteriori" earlier.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix B: Bayesian Belief Networks >  Page 342
</div>
<div class="noteText">
Expressing Doubt The basic GSN as defined in version 2 of the standard does not allow the analyst to express doubt. This restriction is removed if eliminative argumentation as described on page 330 is used. BBNs intrinsically allow doubt to be expressed. 
</div>
<div class="noteHeading">
Note - Appendix B: Bayesian Belief Networks >  Page 342
</div>
<div class="noteText">
Very funny! As if not expressing something eliminates it!

This maybe part of our current human culture and this factor (culture) mustn't be ignored.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix C: Calculating (2+3)+4 >  Page 345
</div>
<div class="noteText">
Errors to be Detected Coded processing is designed to detect three types of error: 
</div>
<div class="noteHeading">
Note - Appendix C: Calculating (2+3)+4 >  Page 345
</div>
<div class="noteText">
Would be nice to put a name to the cryptic "AN.*" acronyms.

And it isn't clear whether, for example, bit-flips cause opcodes to change to non-arithmetic instructions or even trigger a CPU trap/exception.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix C: Calculating (2+3)+4 >  Page 346
</div>
<div class="noteText">
Coded Processing As described in chapter 10, coded processing requires the use of a large prime number,
</div>
<div class="noteHeading">
Note - Appendix C: Calculating (2+3)+4 >  Page 346
</div>
<div class="noteText">
I don't remember "Coded Processing" being explained in the book, and anyways, it'd be best to make the content here standalone.

Either by explaining it or just giving a brief explanation instead of the current situation of a half-baked explanation.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 349
</div>
<div class="noteText">
‚àÄ for each 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 349
</div>
<div class="noteText">
I'm not much of a mathematician, but wouldn't "for all" be more accurate than "for each"?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 349
</div>
<div class="noteText">
a  b a is much greater than b 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 349
</div>
<div class="noteText">
Can't remember seeing this symbol used in the book.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 350
</div>
<div class="noteText">
‚àÄx ‚àà R ‚àÉy ‚àà R with y > x 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 350
</div>
<div class="noteText">
I haven't become much of a mathematician in the time from the previous note, but isn't typically "where" used here instead of "when?"
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 350
</div>
<div class="noteText">
‚ÄúInfix‚Äù here means that the operator is placed between its operands. Thus, a + b rather than +(a, b). 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 350
</div>
<div class="noteText">
Might as well briefly explain postfix too.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 351
</div>
<div class="noteText">
Consider the simple system shown at the top of Figure 10.1 on page 141.
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 351
</div>
<div class="noteText">
Would be very convenient to display figures here as it's much more economical to do it once than have every single reader do this.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 351
</div>
<div class="noteText">
Given the definition of œÜ(~x), it is easy to see that for a set of components in series (as with old-fashioned Christmas tree lights), where all components must operate correctly for the system to operate: 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 351
</div>
<div class="noteText">
I'm not much of an electronics expert but isn't these lights being series or parallel an implementation detail and a hobbyist can do the lights either way.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 352
</div>
<div class="noteText">
Russell resolved this paradox to general, although not universal, acceptance in reference
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 352
</div>
<div class="noteText">
Do you mean here "a general" or "the general"?
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 354
</div>
<div class="noteText">
There are, however, statements than can be expressed in LTL
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 354
</div>
<div class="noteText">
Typo: "than can."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 354
</div>
<div class="noteText">
One example is concept that a property will eventually become true and then remain true forever,
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 354
</div>
<div class="noteText">
Typo: "one example is concept."
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 354
</div>
<div class="noteText">
whereas LTL is generally of exponential complexity. 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 354
</div>
<div class="noteText">
Would be nice to mention, for example, if it's NP-Complete or NP-Hard.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 355
</div>
<div class="noteText">
Both CTL and LTL are subsets of a larger symbology known as CTL*, and everything that can be expressed in either CTL or LTL can be expressed in CTL*. However, it can be difficult to write in CTL* because of its expressive complexity. 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 355
</div>
<div class="noteText">
Would be nice to mention/list tools/programs that are related to Temporal Logic here.

This applies to all appendices and many parts of the book. And both a tools appendex and a section in all chapters of the book maybe useful too.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 355
</div>
<div class="noteText">
Vector Bases 
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 355
</div>
<div class="noteText">
Can't really understand how vector-bases are related to temporal-logic and then why are they under the same appendix.
</div>
<div class="noteHeading">
Highlight (<span class="highlight_yellow">yellow</span>) - Appendix D: Notations >  Page 356
</div>
<div class="noteText">
Returning to the table on page 267,
</div>
<div class="noteHeading">
Note - Appendix D: Notations >  Page 356
</div>
<div class="noteText">
Would be nice to display the table here too.
</div>

        </div>
    </body>
</html>
